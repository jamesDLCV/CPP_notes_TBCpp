// ch06.11-3_MemoryLeak.cpp
//

#include <iostream>
using namespace std;

int main()
{
    cout << "memory leak" << endl;

    while (true)
    {
        int* ptr7 = new int;      // 포인터 변수가 사라진다.
        cout << ptr7 << endl;     // 그러므로 알 수 없는 주소들이 계속 출력된다.
        delete ptr7;              // delete을 해 주면 메모리 누수가 생기지 않는다.
    }
    // delete을 안 해 주면,
    // 지나가는 사람한테 전화 번호 쪽지를 받았는데 그냥 사라져 버리는 것과 같다.
    // 이 지나가는 사람을 다시 만나기 전에는 전화 번호를 알 수가 없다.
    // 컴퓨터 메모리를 다시 만날 일은 없다.
    // 만나더라도 그 메모리가 이 메모리였는지 알 길이 없다.
    // 그래서 int* ptr7 = new int; 와 같이 짜는 건 말도 안 되는 짓이다.
    // 하지만 이런 실수를 프로그래머들이 많이 한다.
    // 동적 메모리 할당 할 때 지우는 것을 깜박하면 문제가 생긴다.

    // 이 문제를 파악하는 방법이 두 가지가 있다.
    // new int 메모리에 할당받은 데이터가 클 경우에는,
    // windows task manager를 띄우고 메모리 사용량을 본다.
    // Memory 사용량이 쭉 올라가면 메모리가 세고 있는 것이다.
    // 그 다음 방법은,
    // debugging 창을 띄우면, Diagnostics session이 쭉 올라가는 것을 볼 수 있다.
    // 1, 2, 3, 4, 5mb 계속 증가한다. <- 굉장히 위험하다.
    // 이번에는 위 while문 안에 delete ptr7; 을 넣어 주고 디버거를 띄워 봐라.
    // debugging 창을 띄우면, 942kb에서 더 이상 증가하지 않는다. 메로리가 새고 있지 않다.
    // 메모리를 받았다가 돌려주고 받았다가 돌려주고를 반복한다.

    // new와 delete을 사용하면 받았다가 돌려줬다 하므로 프로그램이 느려진다.
    // 가능하면 new와 delete을 적게 사용하는 것이 좋다.
    // 새로 나온 언어들 중 new와 delete을 사용 안 하는 언어들은 new와 delete이
    // 언제 사용되는지 알 길이 없다. 그래서 느려질 수밖에 없다.
    // C++를 쓰면 new와 delete을 직접 관리할 수 있으므로 최적화할 때 아주 좋다.
    // 대신에 프로그래밍이 좀 어렵고 실수할 가능성이 많다.
    // 최근에 그를 보완하는 방법이 많이 나오고 있다. 뒷 부분에서 다룬다.

    // 동적 메모리 할당, new와 delete의 사용법에 대해서 변수 하나를 가지고 살펴 봤다.
    // 기본적으로 stack을 사용하기 때문에,
    // 동적 메모리 할당을 써야지만 heap을 사용해서 메모리를 크게 받을 수 있다.
    // 메모리가 세는지 확인하는 방법도 살펴 봤다. delete을 잘 안 해주면 메모리가 센다.
    // 이 부분은 반복해서 좋아하는 프로그램을 만들어 보면서 익히는 것이 가장 좋다.

    return 0;
}
